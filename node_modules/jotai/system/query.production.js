System.register(["react-query","jotai"],function(D){"use strict";var P,g,q,A,u;return{setters:[function(l){P=l.QueryClient,g=l.QueryObserver,q=l.InfiniteQueryObserver,A=l.isCancelledError},function(l){u=l.atom}],execute:function(){D({atomWithInfiniteQuery:E,atomWithQuery:_});const l=D("queryClientAtom",u(new P));function _(r,v=o=>o(l)){const o=u(a=>{const i=v(a),e=typeof r=="function"?r(a):r;let n=null;const s=(()=>{let t=i.getQueryData(e.queryKey);return t===void 0&&e.initialData&&(t=typeof e.initialData=="function"?e.initialData():e.initialData),t})(),h=u(s===void 0&&e.enabled!==!1?new Promise((t,O)=>{n=(w,p)=>{p?O(p):t(w)}}):s);let d=()=>{throw new Error("atomWithQuery: setting data without mount")};const y=t=>{if(t.error){n?(n(void 0,t.error),n=null):d(Promise.reject(t.error));return}t.data!==void 0&&(n?(n(t.data),n=null):d(t.data))},c=i.defaultQueryObserverOptions(e);s===void 0&&e.enabled!==!1&&typeof c.staleTime!="number"&&(c.staleTime=1e3);const m=new g(i,c);return s===void 0&&e.enabled!==!1&&m.fetchOptimistic(c).then(y).catch(t=>y({error:t})),h.onMount=t=>{if(d=t,e.enabled!==!1)return m.subscribe(y)},{dataAtom:h,observer:m}},(a,i,e)=>{switch(e.type){case"refetch":{const{dataAtom:n,observer:b}=a(o);return i(n,new Promise(()=>{})),Promise.resolve().then(()=>b.refetch({cancelRefetch:!0})).then(()=>{})}default:throw new Error("no action")}});return u(a=>{const{dataAtom:i}=a(o);return a(i)},(a,i,e)=>i(o,e))}var Q=Object.getOwnPropertySymbols,I=Object.prototype.hasOwnProperty,C=Object.prototype.propertyIsEnumerable,j=(r,v)=>{var o={};for(var f in r)I.call(r,f)&&v.indexOf(f)<0&&(o[f]=r[f]);if(r!=null&&Q)for(var f of Q(r))v.indexOf(f)<0&&C.call(r,f)&&(o[f]=r[f]);return o};function E(r,v=o=>o(l)){const o=u(a=>{const i=v(a),e=typeof r=="function"?r(a):r;let n=null;const s=(()=>{let t=i.getQueryData(e.queryKey);return t===void 0&&e.initialData&&(t=typeof e.initialData=="function"?e.initialData():e.initialData),t})(),h=u(s===void 0&&e.enabled!==!1?new Promise((t,O)=>{n=(w,p)=>{p?O(p):t(w)}}):s);let d=()=>{throw new Error("atomWithInfiniteQuery: setting data without mount")};const y=t=>{if(t.error&&!A(t.error)){n?(n(void 0,t.error),n=null):d(Promise.reject(t.error));return}t.data!==void 0&&(n?(n(t.data),n=null):d(t.data))},c=i.defaultQueryObserverOptions(e);s===void 0&&e.enabled!==!1&&typeof c.staleTime!="number"&&(c.staleTime=1e3);const m=new q(i,c);return s===void 0&&e.enabled!==!1&&m.fetchOptimistic(c).then(y).catch(t=>y({error:t})),h.onMount=t=>{if(d=t,e.enabled!==!1)return m.subscribe(y)},{dataAtom:h,observer:m,options:e}},(a,i,e)=>{const{observer:n}=a(o);switch(e.type){case"refetch":{const b=e,s=j(b,["type"]);n.refetch(s);break}case"fetchPreviousPage":{n.fetchPreviousPage();break}case"fetchNextPage":{n.fetchNextPage();break}}});return u(a=>{const{dataAtom:i}=a(o);return a(i)},(a,i,e)=>i(o,e))}}}});
